#ifndef _ABSTRACT_H_
#define _ABSTRACT_H_

#include "types.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <map>
#include <algorithm>
#include <numeric>

namespace abstract {

    /**
     * AbstractSystem is responsible for collecting definitions from commits
     * and building a semantic graph that connects definitions with their occurrences.
     * It calculates statistical data like occurrence frequency and temporal distribution.
     */
    class base {
    private:
        // Map from definition symbol to definition object
        std::unordered_map<std::string, types::definition> definitions;
        
        // Vector of all commits (ordered chronologically)
        std::vector<types::summary*> summaries;
        
        // Total number of commits processed
        size_t totalCommits;
        
        // Current clustering results
        std::vector<types::cluster*> clusters;
        
        /**
         * Process a single summary and extract its definitions
         */
        void processCommit(const types::summary* summary, unsigned int timeIndex);
        
        /**
         * Add or update a definition in the system
         */
        void addDefinition(const std::string& symbol, unsigned int commitIndex, float weight);
        
        /**
         * Calculate normalized occurrence values for all definitions
         */
        void calculateOccurrences();
        
        /**
         * Calculate chronicPoint values for all definitions
         * ChronicPoint represents the normalized temporal center of mass for each definition
         */
        void calculateChronicPoints();
        
        /**
         * Calculate connection weights based on summary time and total commits
         */
        float calculateConnectionWeight(unsigned int timeIndex, size_t totalCommits) const;
        
        /**
         * Build similarity matrix between all definitions
         */
        std::vector<std::vector<float>> buildSimilarityMatrix();

        float getAverageChronicRadius(const std::vector<size_t>& indicies);

        float getAverageOccurrenceRadius(const std::vector<size_t>& indicies);

        float getAverageClusterRadius(const std::vector<size_t>& indicies);

        float getAverageDotProductRadius(const std::vector<size_t>& indicies, std::vector<std::pair<std::string, types::definition>>& defsVector);

        float getAverageClusterSimilarityRadius(const std::vector<size_t>& indicies, const std::vector<float>& averageClusterSimilarity);

        // ---- Clustering algorithms -----

        void lokiClustering();

        void chronicClustering();

        void occurrenceClustering();

        void dissonanceHubClustering();

        void resonanceHubClustering();

        // ----- Expectation-Maximization optimization for clustering -----

        void gradientDecent();

        // ----- Clustering tools -----
    
        float dotProduct(types::node::base* a, types::node::base* b, std::vector<float>& result);

    public:
        /**
         * Constructor
         */
        base();
        
        /**
         * Destructor
         */
        ~base();
        
        /**
         * Process a vector of commits and build the abstract system
         * Commits should be in chronological order (oldest first)
         */
        void processSummaries(const std::vector<types::json::parsable*>& commits);
        
        /**
         * Get statistics about the abstract system
         */
        struct abstractStats {
            size_t totalDefinitions;
            size_t totalConnections;
            size_t totalCommits;
            float averageOccurrence;
            float averageChronicPoint;
            float averageConnectionsPerDefinition;
        };
        
        abstractStats getStatistics() const;
        
        /**
         * Clear all data from the system
         */
        void clear();
        
        /**
         * Perform clustering using all available methods
         * This generates hierarchical, DBSCAN, and Louvain clusters
         */
        void cluster();
        
        /**
         * Get all clusters generated by the system
         */
        const std::vector<types::cluster*>& getClusters();
        
        /**
         * Get clusters of a specific type
         */
        std::vector<types::cluster*> getClustersByType(types::node::Type type);
        
        /**
         * Get the total number of processed commits
         */
        size_t getTotalCommits() const;

        float getEntropy();

        float getVariance();

        float getAverageClusterSize();

        float getSilhouetteScore();
        
        /**
         * Legacy methods needed for testing - to be removed in future versions
         */
        const std::unordered_map<std::string, types::definition>& getDefinitions() const;
        const types::definition* getDefinition(const std::string& symbol) const;
        std::vector<std::pair<std::string, types::definition>> getDefinitionsVector();
        std::vector<types::definition> getDefinitionsByOccurrence();
        std::vector<types::definition> findTemporallyRelatedDefinitions(const std::string& symbol, float threshold) const;
        std::vector<types::definition> findCoOccurringDefinitions(const std::string& symbol, float threshold) const;
        std::vector<float> getConnectionWeightsVector(const types::definition& definition) const;
        float calculateCosineSimilarity(const types::definition& def1, const types::definition& def2) const;
    };

}

#endif