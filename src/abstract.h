#ifndef _ABSTRACT_H_
#define _ABSTRACT_H_

#include "types.h"
#include <string>
#include <vector>
#include <unordered_map>
#include <map>
#include <algorithm>
#include <numeric>

namespace abstract {

    /**
     * AbstractSystem is responsible for collecting definitions from commits
     * and building a semantic graph that connects definitions with their occurrences.
     * It calculates statistical data like occurrence frequency and temporal distribution.
     */
    class AbstractSystem {
    private:
        // Map from definition symbol to definition object
        std::unordered_map<std::string, types::definition> definitions;
        
        // Vector of all commits (ordered chronologically)
        std::vector<types::commit> commits;
        
        // Total number of commits processed
        size_t totalCommits;
        
        // Current clustering results
        std::vector<types::cluster::base*> clusters;
        
        /**
         * Process a single commit and extract its definitions
         */
        void processCommit(const types::commit& commit, unsigned int timeIndex);
        
        /**
         * Add or update a definition in the system
         */
        void addDefinition(const std::string& symbol, unsigned int commitIndex, float weight);
        
        /**
         * Calculate normalized occurrence values for all definitions
         */
        void calculateOccurrences();
        
        /**
         * Calculate chronicPoint values for all definitions
         * ChronicPoint represents the normalized temporal center of mass for each definition
         */
        void calculateChronicPoints();
        
        /**
         * Calculate connection weights based on commit time and total commits
         */
        float calculateConnectionWeight(unsigned int timeIndex, size_t totalCommits) const;
        
        /**
         * Build similarity matrix between all definitions
         */
        std::vector<std::vector<float>> buildSimilarityMatrix() const;

        float getAverageChronicRadius(const std::vector<size_t>& indicies);

        float getAverageOccurrenceRadius(const std::vector<size_t>& indicies);

        // ---- Clustering algorithms -----

        void chronicClustering();

        void occurrenceClustering();
    
    public:
        /**
         * Constructor
         */
        AbstractSystem();
        
        /**
         * Destructor
         */
        ~AbstractSystem();
        
        /**
         * Process a vector of commits and build the abstract system
         * Commits should be in chronological order (oldest first)
         */
        void processCommits(const std::vector<types::commit>& commits);
        
        /**
         * Get statistics about the abstract system
         */
        struct AbstractStats {
            size_t totalDefinitions;
            size_t totalConnections;
            size_t totalCommits;
            float averageOccurrence;
            float averageChronicPoint;
            float averageConnectionsPerDefinition;
        };
        
        AbstractStats getStatistics() const;
        
        /**
         * Clear all data from the system
         */
        void clear();
        
        /**
         * Perform clustering using all available methods
         * This generates hierarchical, DBSCAN, and Louvain clusters
         */
        void cluster();
        
        /**
         * Get all clusters generated by the system
         */
        const std::vector<types::cluster::base*>& getClusters() const;
        
        /**
         * Get clusters of a specific type
         */
        std::vector<types::cluster::base*> getClustersByType(types::cluster::Type type) const;
        
        /**
         * Get the total number of processed commits
         */
        size_t getTotalCommits() const;
        
        /**
         * Legacy methods needed for testing - to be removed in future versions
         */
        const std::unordered_map<std::string, types::definition>& getDefinitions() const;
        const types::definition* getDefinition(const std::string& symbol) const;
        std::vector<std::pair<std::string, types::definition>> getDefinitionsVector() const;
        std::vector<types::definition> getDefinitionsByOccurrence() const;
        std::vector<types::definition> findTemporallyRelatedDefinitions(const std::string& symbol, float threshold) const;
        std::vector<types::definition> findCoOccurringDefinitions(const std::string& symbol, float threshold) const;
        std::vector<float> getConnectionWeightsVector(const types::definition& definition) const;
        float calculateCosineSimilarity(const types::definition& def1, const types::definition& def2) const;
    };

}

#endif